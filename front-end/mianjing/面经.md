### <font style="color:#DF2A3F;">3.https是怎么保证安全的，为什么比http安全</font>
<font style="color:#000000;">HTTPS之所以比HTTP更安全，主要是通过以下几种机制来保证其安全性：</font>

1. **<font style="color:#000000;">加密传输</font>**<font style="color:#000000;">：HTTPS使用SSL/TLS协议对HTTP报文进行加密，使得敏感数据在网络传输过程中不容易被窃听和篡改。这种加密过程结合了对称加密和非对称加密，确保数据的保密性和完整性。</font>
2. **<font style="color:#000000;">身份验证</font>**<font style="color:#000000;">：HTTPS通过数字证书进行身份验证，确保通信双方的真实性。在建立HTTPS连接时，服务器会提供数字证书来证明自己的身份。如果验证通过，客户端就可以信任服务器，并继续与其进行安全的数据传输。这有效防止了被恶意伪装的服务器攻击。</font>
3. **<font style="color:#000000;">数据完整性保护</font>**<font style="color:#000000;">：在传输数据之前，HTTPS会对数据进行加密，并使用消息摘要（hash）算法生成一个摘要值。在数据到达接收端后，接收端会使用相同的算法对接收到的数据进行摘要计算，并与发送端的摘要值进行比较。如果两者一致，说明数据在传输过程中没有被篡改。如果不一致，通信双方应重新进行验证或中断连接。</font>

<font style="color:#000000;">这些机制共同作用，使得HTTPS在数据传输、身份验证和数据完整性保护等方面都优于HTTP，从而提供了更高的安全性。因此，对于涉及用户个人隐私和敏感信息的网站，如银行、电商等，使用HTTPS协议可以有效保护用户的账号、密码等信息，提高用户信息的安全性。</font>

### <font style="color:#000000;">4.HTTP的状态码有哪些？并代表什么意思？</font>
<font style="color:#000000;">HTTP状态码是由三位数字组成的代码，用于表示客户端向服务器发起请求后，服务器对请求的响应状态。这些状态码可以大致分为五类，包括信息性状态码、成功状态码、重定向状态码、客户端错误状态码和服务器错误状态码。</font>

<font style="color:#000000;">以下是一些常见的HTTP状态码及其代表的意思：</font>

1. <font style="color:#000000;">1xx（信息性状态码）：</font>
    - **<font style="color:#000000;">100 Continue</font>**<font style="color:#000000;">：客户端应继续其请求。</font>
2. <font style="color:#000000;">2xx（成功状态码）：</font>
    - **<font style="color:#000000;">200 OK</font>**<font style="color:#000000;">：请求成功。</font>
    - **<font style="color:#000000;">201 Created</font>**<font style="color:#000000;">：请求已经被实现，并因此创建了一个新的资源。</font>
    - **<font style="color:#000000;">204 No Content</font>**<font style="color:#000000;">：服务器成功处理了请求，但没有返回任何内容。</font>
3. <font style="color:#000000;">3xx（重定向状态码）：</font>
    - **<font style="color:#000000;">301 Moved Permanently</font>**<font style="color:#000000;">：请求的资源已被永久移动到新的URL上。</font>
    - **<font style="color:#000000;">302 Found</font>**<font style="color:#000000;">：请求的资源现在临时从不同的URL响应请求。</font>
    - **<font style="color:#000000;">304 Not Modified</font>**<font style="color:#000000;">：客户端已经执行了GET请求，但文件未发生变化。</font>
4. <font style="color:#000000;">4xx（客户端错误状态码）：</font>
    - **<font style="color:#000000;">400 Bad Request</font>**<font style="color:#000000;">：服务器无法理解请求。</font>
    - **<font style="color:#000000;">401 Unauthorized</font>**<font style="color:#000000;">：请求要求进行身份验证。</font>
    - **<font style="color:#000000;">403 Forbidden</font>**<font style="color:#000000;">：服务器理解请求，但拒绝执行它。</font>
    - **<font style="color:#000000;">404 Not Found</font>**<font style="color:#000000;">：服务器无法找到请求的资源。</font>
    - **<font style="color:#000000;">405 Method Not Allowed</font>**<font style="color:#000000;">：请求中指定的方法不被允许。</font>
5. <font style="color:#000000;">5xx（服务器错误状态码）：</font>
    - **<font style="color:#000000;">500 Internal Server Error</font>**<font style="color:#000000;">：服务器遇到了一个未曾预料的情况，导致其无法完成对请求的处理。</font>
    - **<font style="color:#000000;">501 Not Implemented</font>**<font style="color:#000000;">：服务器不支持当前请求所需要的某个功能。</font>
    - **<font style="color:#000000;">503 Service Unavailable</font>**<font style="color:#000000;">：由于临时的服务器维护或者过载，服务器当前无法处理请求。</font>

<font style="color:#000000;">这些状态码为客户端和服务器之间的通信提供了丰富的反馈机制，使得双方可以更好地理解请求的处理情况和可能存在的问题。</font>



### <font style="color:#DF2A3F;">11.为什么会存在跨域及常见跨域的解决办法？</font>
<font style="color:#000000;">跨域问题的存在主要是因为浏览器的同源策略限制。同源策略是浏览器的一种安全机制，旨在防止一个域的脚本与另一个域的内容进行交互，以保护用户免受诸如跨站脚本攻击（XSS）和跨站请求伪造（CSRF）等安全威胁。所谓同源，指的是两个页面具有相同的协议（如http或https）、主机（域名或IP地址）和端口号。当这三个条件中任何一个不匹配时，就会触发跨域问题。</font>

<font style="color:#000000;">为了解决跨域问题，有多种常见的解决方案：</font>

1. **JSONP**<font style="color:#000000;">：利用</font>`<font style="color:#000000;">标签不受同源策略限制的特性，通过动态插入</font>`<font style="color:#000000;">标签来请求不同源的数据。JSONP只支持GET请求，并且需要在服务器端进行相应的配合。</font>
2. **CORS（跨域资源共享）**<font style="color:#000000;"> ：CORS 是一种 W3C 规范，它定义了一种浏览器和服务器交互的方式来确定是否允许跨源请求。通过服务器端设置相应的HTTP头部信息，如</font>`<font style="color:#000000;">Access-Control-Allow-Origin</font>`<font style="color:#000000;">，来允许跨域请求。CORS 支持各种HTTP请求方法，并且更加灵活和安全。</font>
3. **代理服务器**<font style="color:#000000;">：通过搭建一个代理服务器来转发请求，使得前端可以通过代理服务器来间接访问不同源的资源。这样，前端请求实际上是发往同源的代理服务器，再由代理服务器去请求不同源的资源。</font>
4. **使用window.postMessage**<font style="color:#000000;">：window.postMessage是HTML5引入的一个新的API，允许来自不同源的脚本进行通信。通过监听window对象的'message'事件，可以接收其他窗口发送过来的消息。</font>
5. **设置document.domain**<font style="color:#000000;">：如果两个页面属于同一个顶级域名下的不同子域名，可以通过设置</font>`<font style="color:#000000;">document.domain</font>`<font style="color:#000000;">为相同的顶级域名来实现跨域。但是，这种方式存在限制，并且可能引入其他安全风险。</font>

<font style="color:#000000;">在选择跨域解决方案时，需要根据具体的业务场景、安全需求以及技术栈来综合考虑。同时，无论采用哪种方案，都应注意保护用户数据的安全和隐私。</font>



`<font style="color:#DF2A3F;">JavaScript</font>`<font style="color:#DF2A3F;">共有八种数据类型</font>，分别是 **Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt**。

其中 **Symbol** 和 **BigInt** 是ES6 中新增的数据类型：

+ **Symbol**代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
+ **BigInt** 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

这些数据可以分为**原始数据类型**和**引用数据类型（复杂数据类型）**，他们在内存中的存储方式不同。

+ **堆：** 存放**引用数据类型**，引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；**引用数据类型在栈中存储了指针**，该指针指向堆中该实体的起始地址，如`Object`、`Array`、`Function`。
+ **栈：** 存放**原始数据类型**，栈中的简单数据段，占据空间小，属于被频繁使用的数据，如`String`、`Number`、`Null`、`Boolean`。

### <font style="color:#DF2A3F;">20.浏览器存储数据方式有哪些</font>
浏览器存储是指浏览器在本地计算机上保存数据的方式，以便在用户访问网站时能够更快地加载内容，提供更好的用户体验。浏览器存储主要有以下几种方式：

1. **Cookie**：Cookie是一种小型的文本文件，存储在客户端的浏览器中。它主要用于存储用户的身份认证、会话状态等信息。Cookie的大小通常受到浏览器和服务器的限制，一般不超过4KB。每次向同一个域名下发送请求时，都会携带相同的Cookie，这样服务器就能识别客户端的身份信息。然而，由于Cookie的大小限制，它只能用来存储少量的信息。
2. **Web Storage**：Web Storage是HTML5引入的一种新的存储方式，主要包括Local Storage和Session Storage两种类型。
+ **Local Storage**：这种存储方式类似于电脑或手机上的下载功能，可以永久保存数据。除非用户主动删除，否则数据会一直存在。
+ **Session Storage**：与Local Storage不同，Session Storage只在当前会话下有效。当页面关闭时，存储的数据就会被删除。这种方式常用于存储一些临时性的信息，如网页微博之类的密码保存。
1. **IndexedDB**：IndexedDB是一种浏览器本地数据库，可以在客户端浏览器中存储大量的结构化数据。它支持事务操作、索引查询等功能，存储空间相对较大，通常限制为几百MB到几GB。与Web Storage相比，IndexedDB的存储方式更为复杂，但提供了更强大的数据操作能力。

总的来说，浏览器存储提供了多种方式来保存数据，以便在用户访问网站时提供更好的体验。不同的存储方式有各自的特点和适用场景，开发者可以根据实际需求选择适合的存储方式。

##### <font style="color:#DF2A3F;">6.行级元素和块级元素分别有哪些及怎么转换？</font>  
<font style="color:#000000;">常见的块级元素：</font>`<font style="color:#000000;">p、div、form、ul、li、ol、table、h1、h2、h3、h4、h5、h6、dl、dt、dd</font>`
##### <font style="color:#000000;">常见的行级元素：</font>`<font style="color:#000000;">span、a、img、button、input、select</font>`
块级元素：

+ 总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列
+ 宽度缺少时是它的容器的100%，除非设置一个宽度
+ 高度、行高以及外边距和内边距都是可以设置的
+ 块级元素可以容纳其它行级元素和块级元素

行内元素：

+ 和其它元素都会在一行显示
+ 高、行高以及外边距和内边距可以设置
+ 宽度就是文字或者图片的宽度，不能改变
+ 行级元素只能容纳文本或者其它行内元素

使用行内元素需要注意的是：

+ 行内元素设置宽度`width`无效
+ 行内元素设置`height`无效，但是可以通过`line-height`来设置
+ 设置`margin`只有左右有效，上下无效
+ 设置`padding`只有左右有效，上下无效

可以通过`display`属性对行内元素和块级元素进行切换(主要看第 `2、3、4`三个值)：

  


### 11. 对盒模型的理解
CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型 ![](https://cdn.nlark.com/yuque/0/2024/webp/45412035/1732167018061-4a6d080b-b4ad-4fb5-964a-0632c12ae83a.webp)![](https://cdn.nlark.com/yuque/0/2024/webp/45412035/1732167018113-7353a3c5-a117-4905-b353-e5bf4dbea61e.webp) 盒模型都是由四个部分组成的，分别是margin、border、padding和content。

标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：

+ 标准盒模型的width和height属性的范围只包含了content，
+ IE盒模型的width和height属性的范围包含了border、padding和content。

可以通过修改元素的box-sizing属性来改变元素的盒模型：

+ `box-sizeing: content-box`表示标准盒模型（默认值）
+ `box-sizeing: border-box`表示IE盒模型（怪异盒模型）



### <font style="color:#DF2A3F;">5. 水平垂直居中的实现</font>
+ 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要**考虑浏览器兼容问题。**

```plain
css

 代码解读
复制代码.parent {    position: relative;} .child {    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);}
```

+ 利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于**盒子有宽高**的情况：

```plain
css

 代码解读
复制代码.parent {
    position: relative;
}
 
.child {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
}
```

+ 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于**盒子宽高已知**的情况

```plain
css

 代码解读
复制代码.parent {
    position: relative;
}
 
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -50px;     /* 自身 height 的一半 */
    margin-left: -50px;    /* 自身 width 的一半 */
}
```

+ 使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要**考虑兼容的问题**，该方法在移动端用的较多：

```plain
css

 代码解读
复制代码.parent {
    display: flex;
    justify-content:center;
    align-items:center;
}
```

  


### <font style="color:#DF2A3F;">6. 如何根据设计稿进行移动端适配？</font>
移动端适配主要有两个维度：

+ **适配不同像素密度，** 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；
+ **适配不同屏幕大小，** 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。

为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。

  




# <font style="color:#DF2A3F;">判断数组的方式有哪些</font>
+ <font style="color:rgb(79, 79, 79);">通过</font>`<font style="color:rgb(79, 79, 79);">Object.prototype.toString.call()</font>`<font style="color:rgb(79, 79, 79);">做判断 </font>

```plain
js

 代码解读
复制代码Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

+ <font style="color:rgb(79, 79, 79);">通过原型链做判断 </font>

```plain
js

 代码解读
复制代码obj.__proto__ === Array.prototype;
```

+ <font style="color:rgb(79, 79, 79);">通过ES6的</font>`<font style="color:rgb(79, 79, 79);">Array.isArray()</font>`<font style="color:rgb(79, 79, 79);">做判断 </font>

```plain
js

 代码解读
复制代码Array.isArrray(obj);
```

+ <font style="color:rgb(79, 79, 79);">通过</font>`<font style="color:rgb(79, 79, 79);">instanceof</font>`<font style="color:rgb(79, 79, 79);">做判断 </font>

```plain
js

 代码解读
复制代码obj instanceof Array
```

<font style="color:rgb(79, 79, 79);">  
</font>

# <font style="color:#DF2A3F;">ajax、axios、fetch的区别</font>
**ajax**

+ <font style="color:rgb(79, 79, 79);">基于原生</font>`<font style="color:rgb(79, 79, 79);">XHR</font>`<font style="color:rgb(79, 79, 79);">开发，</font>`<font style="color:rgb(79, 79, 79);">XHR</font>`<font style="color:rgb(79, 79, 79);">本身架构不清晰。</font>
+ <font style="color:rgb(79, 79, 79);">针对</font>**MVC**<font style="color:rgb(79, 79, 79);">编程，不符合现在前端MVVM的浪潮。</font>
+ <font style="color:rgb(79, 79, 79);">多个请求之间如果有先后关系的话，就会出现回调地狱</font>
+ <font style="color:rgb(79, 79, 79);">配置和调用方式非常混乱，而且基于事件的异步模型不友好。</font>

**axios**

+ <font style="color:rgb(79, 79, 79);">支持</font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);">API</font>
+ <font style="color:rgb(79, 79, 79);">从浏览器中创建</font>`<font style="color:rgb(79, 79, 79);">XMLHttpRequest</font>`
+ <font style="color:rgb(79, 79, 79);">从 </font>`<font style="color:rgb(79, 79, 79);">node.js</font>`<font style="color:rgb(79, 79, 79);"> 创建 </font>`<font style="color:rgb(79, 79, 79);">http</font>`<font style="color:rgb(79, 79, 79);"> 请求</font>
+ <font style="color:rgb(79, 79, 79);">支持请求拦截和响应拦截</font>
+ <font style="color:rgb(79, 79, 79);">自动转换</font>`<font style="color:rgb(79, 79, 79);">JSON</font>`<font style="color:rgb(79, 79, 79);">数据</font>
+ <font style="color:rgb(79, 79, 79);">客服端支持防止</font>`<font style="color:rgb(79, 79, 79);">CSRF/XSRF</font>`

**fetch**

+ <font style="color:rgb(79, 79, 79);">浏览器原生实现的请求方式，ajax的替代品</font>
+ <font style="color:rgb(79, 79, 79);">基于标准 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 实现，支持</font>`<font style="color:rgb(79, 79, 79);">async/await</font>`
+ `<font style="color:rgb(79, 79, 79);">fetchtch</font>`<font style="color:rgb(79, 79, 79);">只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</font>
+ <font style="color:rgb(79, 79, 79);">默认不会带</font>`<font style="color:rgb(79, 79, 79);">cookie</font>`<font style="color:rgb(79, 79, 79);">，需要添加配置项</font>
+ `<font style="color:rgb(79, 79, 79);">fetch</font>`<font style="color:rgb(79, 79, 79);">没有办法原生监测请求的进度，而</font>`<font style="color:rgb(79, 79, 79);">XHR</font>`<font style="color:rgb(79, 79, 79);">可以。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

# <font style="color:#DF2A3F;">如何实现深浅拷贝</font>
### <font style="color:rgb(79, 79, 79);">深拷贝</font>
+ `<font style="color:rgb(79, 79, 79);">JSON.stringify()</font>`<font style="color:rgb(79, 79, 79);"> 将js对象序列化，再通过</font>`<font style="color:rgb(79, 79, 79);">JSON.parse</font>`<font style="color:rgb(79, 79, 79);">反序列 </font>
    - <font style="color:rgb(79, 79, 79);">如果对象中有函数、</font>`<font style="color:rgb(79, 79, 79);">undefined</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">symbol</font>`<font style="color:rgb(79, 79, 79);">时，都会丢失</font>
    - <font style="color:rgb(79, 79, 79);">如果有正则表达式、</font>`<font style="color:rgb(79, 79, 79);">Error</font>`<font style="color:rgb(79, 79, 79);">对象等，会得到空对象</font>

<font style="color:rgb(79, 79, 79);">「</font>[手写代码-手写深拷贝](https://juejin.cn/spost/7272737742307065914#heading-8)<font style="color:rgb(79, 79, 79);">」</font>

### <font style="color:rgb(79, 79, 79);">浅拷贝</font>
+ `<font style="color:rgb(79, 79, 79);">Objec.assign()</font>`<font style="color:rgb(79, 79, 79);"> 拷贝对象</font>
+ <font style="color:rgb(79, 79, 79);">扩展运算符</font>

<font style="color:rgb(79, 79, 79);">  
</font>

### <font style="color:rgb(79, 79, 79);">2.</font><font style="color:#DF2A3F;"> call() 和 apply() 的区别？</font>
<font style="color:rgb(79, 79, 79);">它们的作用一模一样，区别仅在于传入参数的形式的不同。</font>

+ <font style="color:rgb(79, 79, 79);">apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</font>
+ <font style="color:rgb(79, 79, 79);">call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</font>

### <font style="color:rgb(79, 79, 79);">3. 实现call、apply 及 bind 函数</font>
**（1）call 函数的实现步骤：**

+ <font style="color:rgb(79, 79, 79);">判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</font>
+ <font style="color:rgb(79, 79, 79);">判断传入上下文对象是否存在，如果不存在，则设置为 window 。</font>
+ <font style="color:rgb(79, 79, 79);">处理传入的参数，截取第一个参数后的所有参数。</font>
+ <font style="color:rgb(79, 79, 79);">将函数作为上下文对象的一个属性。</font>
+ <font style="color:rgb(79, 79, 79);">使用上下文对象来调用这个方法，并保存返回结果。</font>
+ <font style="color:rgb(79, 79, 79);">删除刚才新增的属性。</font>
+ <font style="color:rgb(79, 79, 79);">返回结果。</font>

```plain
javascript

 代码解读
复制代码Function.prototype.myCall = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
    result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;
  // 将调用函数设为对象的方法
  context.fn = this;
  // 调用函数
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
};
```

**（2）apply 函数的实现步骤：**

+ <font style="color:rgb(79, 79, 79);">判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</font>
+ <font style="color:rgb(79, 79, 79);">判断传入上下文对象是否存在，如果不存在，则设置为 window 。</font>
+ <font style="color:rgb(79, 79, 79);">将函数作为上下文对象的一个属性。</font>
+ <font style="color:rgb(79, 79, 79);">判断参数值是否传入</font>
+ <font style="color:rgb(79, 79, 79);">使用上下文对象来调用这个方法，并保存返回结果。</font>
+ <font style="color:rgb(79, 79, 79);">删除刚才新增的属性</font>
+ <font style="color:rgb(79, 79, 79);">返回结果</font>

```plain
javascript

 代码解读
复制代码Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  let result = null;
  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;
  // 将函数设为对象的方法
  context.fn = this;
  // 调用方法
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  // 将属性删除
  delete context.fn;
  return result;
};
```

**（3）bind 函数的实现步骤：**

+ <font style="color:rgb(79, 79, 79);">判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</font>
+ <font style="color:rgb(79, 79, 79);">保存当前函数的引用，获取其余传入参数值。</font>
+ <font style="color:rgb(79, 79, 79);">创建一个函数返回</font>
+ <font style="color:rgb(79, 79, 79);">函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</font>

```plain
javascript

 代码解读
复制代码Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  // 获取参数
  var args = [...arguments].slice(1),
    fn = this;
  return function Fn() {
    // 根据调用方式，传入不同绑定值
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
};
```

<font style="color:rgb(79, 79, 79);">  
</font>

<font style="color:rgb(79, 79, 79);"></font>

### <font style="color:#DF2A3F;">2. 如何解决跨越问题</font>
#### <font style="color:rgb(79, 79, 79);">（1）CORS</font>
<font style="color:rgb(79, 79, 79);">下面是MDN对于CORS的定义：</font>

<font style="color:rgb(79, 79, 79);">跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</font>

<font style="color:rgb(79, 79, 79);">CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现</font>**CORS的关键就是服务器，只要服务器实现了CORS请求**<font style="color:rgb(79, 79, 79);">，就可以跨源通信了。</font>

<font style="color:rgb(79, 79, 79);">浏览器将CORS分为</font>**简单请求**<font style="color:rgb(79, 79, 79);">和</font>**非简单请求**<font style="color:rgb(79, 79, 79);">：</font>

<font style="color:rgb(79, 79, 79);">简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</font>

**1）请求方法是以下三种方法之一：**

+ <font style="color:rgb(79, 79, 79);">HEAD</font>
+ <font style="color:rgb(79, 79, 79);">GET</font>
+ <font style="color:rgb(79, 79, 79);">POST</font>

**2）HTTP的头信息不超出以下几种字段：**

+ <font style="color:rgb(79, 79, 79);">Accept</font>
+ <font style="color:rgb(79, 79, 79);">Accept-Language</font>
+ <font style="color:rgb(79, 79, 79);">Content-Language</font>
+ <font style="color:rgb(79, 79, 79);">Last-Event-ID</font>
+ <font style="color:rgb(79, 79, 79);">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</font>

<font style="color:rgb(79, 79, 79);">若不满足以上条件，就属于非简单请求了。</font>

**（1）简单请求过程：**

<font style="color:rgb(79, 79, 79);">对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</font>

```plain
javascript

 代码解读
复制代码Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Expose-Headers: FooBar   // 指定返回其他字段的值
Content-Type: text/html; charset=utf-8   // 表示文档类型
```

<font style="color:rgb(79, 79, 79);">如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</font>

**在简单请求中，在服务器内，至少需要设置字段：**`<font style="color:rgb(79, 79, 79);">Access-Control-Allow-Origin</font>`

**（2）非简单请求过程**

<font style="color:rgb(79, 79, 79);">非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，</font>**称为预检请求**<font style="color:rgb(79, 79, 79);">。</font>

<font style="color:rgb(79, 79, 79);">浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</font>

<font style="color:rgb(79, 79, 79);">预检请求使用的</font>**请求方法是OPTIONS**<font style="color:rgb(79, 79, 79);">，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</font>

+ **Access-Control-Request-Method**<font style="color:rgb(79, 79, 79);">：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</font>
+ **Access-Control-Request-Headers**<font style="color:rgb(79, 79, 79);">： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</font>

<font style="color:rgb(79, 79, 79);">服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</font>

<font style="color:rgb(79, 79, 79);">服务器回应的CORS的字段如下：</font>

```plain
javascript

 代码解读
复制代码Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址
Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒
```

<font style="color:rgb(79, 79, 79);">只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</font>

**在非简单请求中，至少需要设置以下字段：**

```plain
javascript

 代码解读
复制代码'Access-Control-Allow-Origin'  
'Access-Control-Allow-Methods'
'Access-Control-Allow-Headers'
```

##### <font style="color:rgb(79, 79, 79);">减少OPTIONS请求次数：</font>
<font style="color:rgb(79, 79, 79);">OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</font>

##### <font style="color:rgb(79, 79, 79);">CORS中Cookie相关问题：</font>
<font style="color:rgb(79, 79, 79);">在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</font>

+ <font style="color:rgb(79, 79, 79);">在请求中设置 </font>`<font style="color:rgb(79, 79, 79);">withCredentials</font>`

<font style="color:rgb(79, 79, 79);">默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</font>

```plain
javascript

 代码解读
复制代码// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
// axios 设置方式
axios.defaults.withCredentials = true;
```

+ <font style="color:rgb(79, 79, 79);">Access-Control-Allow-Credentials 设置为 true</font>
+ <font style="color:rgb(79, 79, 79);">Access-Control-Allow-Origin 设置为非 </font>`<font style="color:rgb(79, 79, 79);">*</font>`

#### <font style="color:rgb(79, 79, 79);">（2）JSONP</font>
**jsonp**<font style="color:rgb(79, 79, 79);">的原理就是利用</font>`<font style="color:rgb(79, 79, 79);"><script></font>`<font style="color:rgb(79, 79, 79);">标签没有跨域限制，通过</font>`<font style="color:rgb(79, 79, 79);"><script></font>`<font style="color:rgb(79, 79, 79);">标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生JS实现：</font>

```plain
javascript

 代码解读
复制代码<script>
    var script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 </script>
```

<font style="color:rgb(79, 79, 79);">服务端返回如下（返回时即执行全局函数）：</font>

```plain
javascript

 代码解读
复制代码handleCallback({"success": true, "user": "admin"})
```

<font style="color:rgb(79, 79, 79);">2）Vue axios实现：</font>

```plain
javascript

 代码解读
复制代码this.$http = axios;
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

<font style="color:rgb(79, 79, 79);">后端node.js代码：</font>

```plain
javascript

 代码解读
复制代码var querystring = require('querystring');
var http = require('http');
var server = http.createServer();
server.on('request', function(req, res) {
    var params = querystring.parse(req.url.split('?')[1]);
    var fn = params.callback;
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
```

**JSONP的缺点：**

+ <font style="color:rgb(79, 79, 79);">具有局限性， 仅支持get方法</font>
+ <font style="color:rgb(79, 79, 79);">不安全，可能会遭受XSS攻击</font>

#### <font style="color:rgb(79, 79, 79);">（3）postMessage 跨域</font>
<font style="color:rgb(79, 79, 79);">postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</font>

+ <font style="color:rgb(79, 79, 79);">页面和其打开的新窗口的数据传递</font>
+ <font style="color:rgb(79, 79, 79);">多窗口之间消息传递</font>
+ <font style="color:rgb(79, 79, 79);">页面与嵌套的iframe消息传递</font>
+ <font style="color:rgb(79, 79, 79);">上面三个场景的跨域数据传递</font>

<font style="color:rgb(79, 79, 79);">用法：postMessage(data,origin)方法接受两个参数：</font>

+ **data**<font style="color:rgb(79, 79, 79);">： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</font>
+ **origin**<font style="color:rgb(79, 79, 79);">： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。</font>

<font style="color:rgb(79, 79, 79);">1）a.html：(domain1.com/a.html)</font>

```plain
javascript

 代码解读
复制代码<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };
    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>
```

<font style="color:rgb(79, 79, 79);">2）b.html：(domain2.com/b.html)</font>

```plain
javascript

 代码解读
复制代码<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);
        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;
            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
</script>
```

#### <font style="color:rgb(79, 79, 79);">（4）nginx代理跨域</font>
<font style="color:rgb(79, 79, 79);">nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</font>

<font style="color:rgb(79, 79, 79);">1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</font>

```plain
http

 代码解读
复制代码location / {
  add_header Access-Control-Allow-Origin *;
}
```

<font style="color:rgb(79, 79, 79);">2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</font>

<font style="color:rgb(79, 79, 79);">nginx具体配置：</font>

```plain
javascript

 代码解读
复制代码#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;
        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

#### <font style="color:rgb(79, 79, 79);">（5）nodejs 中间件代理跨域</font>
<font style="color:rgb(79, 79, 79);">node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</font>

**1）非vue框架的跨域**<font style="color:rgb(79, 79, 79);"> 使用node + express + http-proxy-middleware搭建一个proxy服务器。</font>

+ <font style="color:rgb(79, 79, 79);">前端代码：</font>

```plain
javascript

 代码解读
复制代码var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问http-proxy-middleware代理服务器
xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
xhr.send();
```

+ <font style="color:rgb(79, 79, 79);">中间件服务器代码：</font>

```plain
javascript

 代码解读
复制代码var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();
app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.domain2.com:8080',
    changeOrigin: true,
    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },
    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
}));
app.listen(3000);
console.log('Proxy server is listen at port 3000...');
```

**2）vue框架的跨域**

<font style="color:rgb(79, 79, 79);">node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</font>

<font style="color:rgb(79, 79, 79);">webpack.config.js部分配置：</font>

```plain
javascript

 代码解读
复制代码module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            context: '/login',
            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
            changeOrigin: true,
            secure: false,  // 当代理某些https服务报错时用
            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}
```

#### <font style="color:rgb(79, 79, 79);">（6）document.domain + iframe跨域</font>
<font style="color:rgb(79, 79, 79);">此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)</font>

```plain
javascript

 代码解读
复制代码<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

<font style="color:rgb(79, 79, 79);">1）子窗口：(child.domain.com/a.html)</font>

```plain
javascript

 代码解读
复制代码<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    console.log('get js data from parent ---> ' + window.parent.user);
</script>
```

#### <font style="color:rgb(79, 79, 79);">（7）location.hash + iframe跨域</font>
<font style="color:rgb(79, 79, 79);">实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</font>

<font style="color:rgb(79, 79, 79);">具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</font>

<font style="color:rgb(79, 79, 79);">1）a.html：(domain1.com/a.html)</font>

```plain
javascript

 代码解读
复制代码<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
```

<font style="color:rgb(79, 79, 79);">2）b.html：(.domain2.com/b.html)</font>

```plain
ini

 代码解读
复制代码<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
```

<font style="color:rgb(79, 79, 79);">3）c.html：(</font>[www.domain1.com/c.html](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fwww.domain1.com%2Fc.html)<font style="color:rgb(79, 79, 79);">)</font>

```plain
javascript

 代码解读
复制代码<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

#### <font style="color:rgb(79, 79, 79);">（8）window.name + iframe跨域</font>
<font style="color:rgb(79, 79, 79);">window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</font>

<font style="color:rgb(79, 79, 79);">1）a.html：(domain1.com/a.html)</font>

```plain
javascript

 代码解读
复制代码var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');
    // 加载跨域页面
    iframe.src = url;
    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();
        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };
    document.body.appendChild(iframe);
    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};
// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});
```

<font style="color:rgb(79, 79, 79);">2）proxy.html：(domain1.com/proxy.html)</font>

<font style="color:rgb(79, 79, 79);">中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)</font>

```plain
javascript

 代码解读
复制代码<script>    
    window.name = 'This is domain2 data!';
</script>
```

<font style="color:rgb(79, 79, 79);">通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</font>

#### <font style="color:rgb(79, 79, 79);">（9）WebSocket协议跨域</font>
<font style="color:rgb(79, 79, 79);">WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</font>

<font style="color:rgb(79, 79, 79);">原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</font>

<font style="color:rgb(79, 79, 79);">1）前端代码：</font>

```plain
javascript

 代码解读
复制代码<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');
// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });
    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});
document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

<font style="color:rgb(79, 79, 79);">2）Nodejs socket后台：</font>

```plain
javascript

 代码解读
复制代码var http = require('http');
var socket = require('socket.io');
// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });
    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```

<font style="color:rgb(79, 79, 79);">  
</font>



### <font style="color:#DF2A3F;">1. 浏览器的渲染过程</font>
<font style="color:rgb(79, 79, 79);">浏览器渲染主要有以下步骤：</font>

+ <font style="color:rgb(79, 79, 79);">首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</font>
+ <font style="color:rgb(79, 79, 79);">然后对 CSS 进行解析，生成 CSSOM 规则树。</font>
+ <font style="color:rgb(79, 79, 79);">根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</font>
+ <font style="color:rgb(79, 79, 79);">当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</font>
+ <font style="color:rgb(79, 79, 79);">布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</font>

<font style="color:rgb(79, 79, 79);">大致过程如图所示： </font>![](https://cdn.nlark.com/yuque/0/2024/webp/45412035/1732167643319-29f01cd3-25dd-4c49-bc36-2dc1126d36ec.webp)

**注意：**<font style="color:rgb(79, 79, 79);"> 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</font>



# <font style="color:#DF2A3F;">节流和防抖</font>
## <font style="color:rgb(79, 79, 79);">节流</font>
<font style="color:rgb(79, 79, 79);">节流是一种常用的性能优化技术，它可以限制函数的执行频率，避免过多的重复操作，提升页面的响应速度。</font>

**函数在 n 秒内只执行一次，如果多次触发，则忽略执行。**

**应用场景**<font style="color:rgb(79, 79, 79);">：</font>

+ <font style="color:rgb(79, 79, 79);">拖拽场景</font>
+ <font style="color:rgb(79, 79, 79);">scroll场景</font>
+ <font style="color:rgb(79, 79, 79);">窗口大小调整</font>

<font style="color:rgb(79, 79, 79);">「</font>[手写代码-节流](https://juejin.cn/post/7272737742307065914#heading-5)<font style="color:rgb(79, 79, 79);">」</font>

## <font style="color:rgb(79, 79, 79);">防抖</font>
<font style="color:rgb(79, 79, 79);">防抖函数可以将多次高频率触发的函数执行合并成一次，并在指定的时间间隔后执行一次。通常在处理输入框、滚动等事件时使用，避免频繁触发事件导致页面卡顿等问题。</font>

**函数在 n 秒后再执行，如果 n 秒内被触发，重新计时，保证最后一次触发事件 n 秒后才执行。**

**应用场景**<font style="color:rgb(79, 79, 79);">：</font>

+ <font style="color:rgb(79, 79, 79);">输入框搜索</font>
+ <font style="color:rgb(79, 79, 79);">表单提交按钮</font>
+ <font style="color:rgb(79, 79, 79);">文本器保存</font>

<font style="color:rgb(79, 79, 79);">「</font>[手写代码-防抖](https://juejin.cn/post/7272737742307065914#heading-6)<font style="color:rgb(79, 79, 79);">」</font>

<font style="color:rgb(79, 79, 79);">  
</font>

<font style="color:rgb(79, 79, 79);">作者：wakaka378  
</font><font style="color:rgb(79, 79, 79);">链接：https://juejin.cn/post/7273119689185673253  
</font><font style="color:rgb(79, 79, 79);">来源：稀土掘金  
</font><font style="color:rgb(79, 79, 79);">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</font>

## <font style="color:#DF2A3F;">说说你对Promise的理解</font>
`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);">是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了地狱回调。</font>

`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);">的实例有三个状态:</font>

+ `<font style="color:rgb(79, 79, 79);">Pending</font>`<font style="color:rgb(79, 79, 79);">（初始状态）</font>
+ `<font style="color:rgb(79, 79, 79);">Fulfilled</font>`<font style="color:rgb(79, 79, 79);">（成功状态）</font>
+ `<font style="color:rgb(79, 79, 79);">Rejected</font>`<font style="color:rgb(79, 79, 79);">（失败状态）</font>

`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);">的实例有两个过程：</font>

+ `<font style="color:rgb(79, 79, 79);">pending</font>`<font style="color:rgb(79, 79, 79);"> -> </font>`<font style="color:rgb(79, 79, 79);">fulfilled</font>`<font style="color:rgb(79, 79, 79);"> : </font>**Resolved（已完成）**
+ `<font style="color:rgb(79, 79, 79);">pending</font>`<font style="color:rgb(79, 79, 79);"> -> </font>`<font style="color:rgb(79, 79, 79);">rejected</font>`<font style="color:rgb(79, 79, 79);">：</font>**Rejected（已拒绝）**

<font style="color:rgb(79, 79, 79);">注意：一旦从进行状态变成为其他状态就永远不能更改状态了，其过程是不可逆的。</font>

### <font style="color:#DF2A3F;">4. Promise的基本用法</font>
#### （1）创建Promise对象
Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。

```plain
javascript

 代码解读
复制代码const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
```

**一般情况下都会使用**`new Promise()`**来创建promise对象，但是也可以使用**`promise.resolve`**和**`promise.reject`**这两个方法：**

+ **Promise.resolve**

`Promise.resolve(value)`的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：

```plain
javascript

 代码解读
复制代码Promise.resolve(11).then(function(value){
  console.log(value); // 打印出11
});
```

`resolve(11)`代码中，会让promise对象进入确定(`resolve`状态)，并将参数`11`传递给后面的`then`所指定的`onFulfilled` 函数；

创建promise对象可以使用`new Promise`的形式创建对象，也可以使用`Promise.resolve(value)`的形式创建promise对象；

+ **Promise.reject**

`Promise.reject` 也是`new Promise`的快捷形式，也创建一个promise对象。代码如下：

```plain
javascript

 代码解读
复制代码Promise.reject(new Error(“我错了，请原谅俺！！”));
```

就是下面的代码new Promise的简单形式：

```plain
javascript

 代码解读
复制代码new Promise(function(resolve,reject){
   reject(new Error("我错了！"));
});
```

下面是使用resolve方法和reject方法：

```plain
javascript

 代码解读
复制代码function testPromise(ready) {
  return new Promise(function(resolve,reject){
    if(ready) {
      resolve("hello world");
    }else {
      reject("No thanks");
    }
  });
};
// 方法调用
testPromise(true).then(function(msg){
  console.log(msg);
},function(error){
  console.log(error);
});
```

上面的代码的含义是给`testPromise`方法传递一个参数，返回一个promise对象，如果为`true`的话，那么调用promise对象中的`resolve()`方法，并且把其中的参数传递给后面的`then`第一个函数内，因此打印出 “`hello world`”, 如果为`false`的话，会调用promise对象中的`reject()`方法，则会进入`then`的第二个函数内，会打印`No thanks`；

#### （2）Promise方法
Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。

1. **then()**

当Promise执行的内容符合成功条件时，调用`resolve`函数，失败就调用`reject`函数。Promise创建完了，那该如何调用呢？

```plain
javascript

 代码解读
复制代码promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```

`then`方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为`resolved`时调用，第二个回调函数是Promise对象的状态变为`rejected`时调用。其中第二个参数可以省略。 `then`方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即`then`方法后面再调用另一个then方法。

当要写有顺序的异步事件时，需要串行时，可以这样写：

```plain
javascript

 代码解读
复制代码let promise = new Promise((resolve,reject)=>{
    ajax('first').success(function(res){
        resolve(res);
    })
})
promise.then(res=>{
    return new Promise((resovle,reject)=>{
        ajax('second').success(function(res){
            resolve(res)
        })
    })
}).then(res=>{
    return new Promise((resovle,reject)=>{
        ajax('second').success(function(res){
            resolve(res)
        })
    })
}).then(res=>{
    
})
```

那当要写的事件没有顺序或者关系时，还如何写呢？可以使用`all` 方法来解决。

**2. catch()**

Promise对象除了有then方法，还有一个catch方法，该方法相当于`then`方法的第二个参数，指向`reject`的回调函数。不过`catch`方法还有一个作用，就是在执行`resolve`回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入`catch`方法中。

```plain
javascript

 代码解读
复制代码p.then((data) => {
     console.log('resolved',data);
},(err) => {
     console.log('rejected',err);
     }
); 
p.then((data) => {
    console.log('resolved',data);
}).catch((err) => {
    console.log('rejected',err);
});
```

**3. all()**

`all`方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`的时候，`all`方法的状态就会变成`resolved`，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`。

```plain
javascript

 代码解读
复制代码javascript
let promise1 = new Promise((resolve,reject)=>{
	setTimeout(()=>{
       resolve(1);
	},2000)
});
let promise2 = new Promise((resolve,reject)=>{
	setTimeout(()=>{
       resolve(2);
	},1000)
});
let promise3 = new Promise((resolve,reject)=>{
	setTimeout(()=>{
       resolve(3);
	},3000)
});
Promise.all([promise1,promise2,promise3]).then(res=>{
    console.log(res);
    //结果为：[1,2,3] 
})
```

调用`all`方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象`resolve`执行时的值。

**（4）race()**

`race`方法和`all`一样，接受的参数是一个每项都是`promise`的数组，但是与`all`不同的是，当最先执行完的事件执行完之后，就直接返回该`promise`对象的值。如果第一个`promise`对象状态变成`resolved`，那自身的状态变成了`resolved`；反之第一个`promise`变成`rejected`，那自身状态就会变成`rejected`。

```plain
javascript

 代码解读
复制代码let promise1 = new Promise((resolve,reject)=>{
	setTimeout(()=>{
       reject(1);
	},2000)
});
let promise2 = new Promise((resolve,reject)=>{
	setTimeout(()=>{
       resolve(2);
	},1000)
});
let promise3 = new Promise((resolve,reject)=>{
	setTimeout(()=>{
       resolve(3);
	},3000)
});
Promise.race([promise1,promise2,promise3]).then(res=>{
	console.log(res);
	//结果：2
},rej=>{
    console.log(rej)};
)
```

那么`race`方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：

```plain
javascript

 代码解读
复制代码Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})
```

**5. finally()**

`finally`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。

```plain
javascript

 代码解读
复制代码promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

上面代码中，不管`promise`最后的状态，在执行完`then`或`catch`指定的回调函数以后，都会执行`finally`方法指定的回调函数。

下面是一个例子，服务器使用 Promise 处理请求，然后使用`finally`方法关掉服务器。

```plain
javascript

 代码解读
复制代码server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
```

`finally`方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是`fulfilled`还是`rejected`。这表明，`finally`方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。`finally`本质上是`then`方法的特例：

```plain
javascript

 代码解读
复制代码promise
.finally(() => {
  // 语句
});
// 等同于
promise
.then(
  result => {
    // 语句
    return result;
  },
  error => {
    // 语句
    throw error;
  }
);
```

上面代码中，如果不使用`finally`方法，同样的语句需要为成功和失败两种情况各写一次。有了`finally`方法，则只需要写一次。

### 5. Promise解决了什么问题
在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：

```plain
javascript

 代码解读
复制代码let fs = require('fs')
fs.readFile('./a.txt','utf8',function(err,data){
  fs.readFile(data,'utf8',function(err,data){
    fs.readFile(data,'utf8',function(err,data){
      console.log(data)
    })
  })
})
```

上面的代码有如下缺点：

+ 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
+ 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。

`Promise`出现之后，代码变成这样：

```plain
javascript

 代码解读
复制代码let fs = require('fs')
function read(url){
  return new Promise((resolve,reject)=>{
    fs.readFile(url,'utf8',function(error,data){
      error && reject(error)
      resolve(data)
    })
  })
}
read('./a.txt').then(data=>{
  return read(data) 
}).then(data=>{
  return read(data)  
}).then(data=>{
  console.log(data)
})
```

这样代码看起了就简洁了很多，解决了地狱回调的问题。

### 6. Promise.all和Promise.race的区别的使用场景
**（1）Promise.all**`Promise.all`可以将多个`Promise`实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是**一个结果数组**，而失败的时候则返回**最先被reject失败状态的值**。

Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。

需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。

**（2）Promise.race**

顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：

```plain
javascript

 代码解读
复制代码Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})
```

### 7. 对async/await 的理解
async/await其实是`Generator` 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：

```plain
javascript

 代码解读
复制代码async function testAsy(){
   return 'hello world';
}
let result = testAsy(); 
console.log(result)
```

![](https://cdn.nlark.com/yuque/0/2024/webp/45412035/1732168034682-66301365-17d4-4074-bd82-39217d3913c8.webp)

所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。

async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样：

```plain
javascript

 代码解读
复制代码async function testAsy(){
   return 'hello world'
}
let result = testAsy() 
console.log(result)
result.then(v=>{
    console.log(v)   // hello world
})
```

那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。

联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。

**注意：**`Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。

### 8. await 到底在等啥？
**await 在等待什么呢？** 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。

因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：

```plain
javascript

 代码解读
复制代码function getSomething() {
    return "something";
}
async function testAsync() {
    return Promise.resolve("hello async");
}
async function test() {
    const v1 = await getSomething();
    const v2 = await testAsync();
    console.log(v1, v2);
}
test();
```

await 表达式的运算结果取决于它等的是什么。

+ 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
+ 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

来看一个例子：

```plain
javascript

 代码解读
复制代码function testAsy(x){
   return new Promise(resolve=>{setTimeout(() => {
       resolve(x);
     }, 3000)
    }
   )
}
async function testAwt(){    
  let result =  await testAsy('hello world');
  console.log(result);    // 3秒钟之后出现hello world
  console.log('cuger')   // 3秒钟之后出现cug
}
testAwt();
console.log('cug')  //立即输出cug
```

这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。

### 9. async/await的优势
单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。

假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 `setTimeout` 来模拟异步操作：

```plain
javascript

 代码解读
复制代码/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}
function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}
function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}
function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

现在用 Promise 方式来实现这三个步骤的处理：

```plain
javascript

 代码解读
复制代码function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}
doIt();
// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms
```

输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。

如果用 async/await 来实现呢，会是这样：

```plain
javascript

 代码解读
复制代码async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}
doIt();
```

结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样

### 10. async/await对比Promise的优势
+ 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
+ Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
+ 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
+ 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。

### 11. async/await 如何捕获异常
```plain
javascript

 代码解读
复制代码async function fn(){
    try{
        let a = await Promise.reject('error')
    }catch(error){
        console.log(error)
    }
}
```

  


<font style="color:rgb(79, 79, 79);">  
</font>

# <font style="color:#DF2A3F;">原型</font>
+ **prototype**<font style="color:rgb(79, 79, 79);"> : js通过构造函数来创建对象，每个构造函数内部都会一个原型</font>`<font style="color:rgb(79, 79, 79);">prototype</font>`<font style="color:rgb(79, 79, 79);">属性，它指向另外一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</font>
+ **proto**<font style="color:rgb(79, 79, 79);">: 当使用构造函数创建一个实例对象后，可以通过</font>`<font style="color:rgb(79, 79, 79);">__proto__</font>`<font style="color:rgb(79, 79, 79);">访问到</font>`<font style="color:rgb(79, 79, 79);">prototype</font>`<font style="color:rgb(79, 79, 79);">属性。</font>
+ **constructor**<font style="color:rgb(79, 79, 79);">：实例对象通过这个属性可以访问到构造函数</font>

# <font style="color:rgb(79, 79, 79);">原型链</font>
<font style="color:rgb(79, 79, 79);">每个实例对象都有一个</font>`<font style="color:rgb(79, 79, 79);">__proto__</font>`<font style="color:rgb(79, 79, 79);">属性指向它的构造函数的原型对象，而这个原型对象也会有自己的原型对象，一层一层向上，直到顶级原型对象</font>`<font style="color:rgb(79, 79, 79);">null</font>`<font style="color:rgb(79, 79, 79);">，这样就形成了一个原型链。</font>

<font style="color:rgb(79, 79, 79);">当访问对象的一个属性或方法时，当对象身上不存在该属性方法时，就会沿着原型链向上查找，直到查找到该属性方法位置。</font>

<font style="color:rgb(79, 79, 79);">原型链的顶层原型是</font>`<font style="color:rgb(79, 79, 79);">Object.prototype</font>`<font style="color:rgb(79, 79, 79);">，如果这里没有就只指向</font>`<font style="color:rgb(79, 79, 79);">null</font>`

<font style="color:rgb(79, 79, 79);">  
</font>

# <font style="color:#DF2A3F;">对闭包的理解已经它的使用场景</font>
**闭包是指有权访问另一个函数作用域中变量的函数**<font style="color:rgb(79, 79, 79);">，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</font>

**闭包优点：**

+ <font style="color:rgb(79, 79, 79);">创建全局私有变量，避免变量全局污染</font>
+ <font style="color:rgb(79, 79, 79);">可以实现封装、缓存等</font>

**闭包缺点：**

+ <font style="color:rgb(79, 79, 79);">创建的变量不能被回收，容易消耗内存，使用不当会导致内存溢出 </font>
    - **解决：**<font style="color:rgb(79, 79, 79);"> 在不需要使用的时候把变量设为</font>`<font style="color:rgb(79, 79, 79);">null</font>`

**使用场景：**

+ <font style="color:rgb(79, 79, 79);">用于创建全局私有变量</font>
+ <font style="color:rgb(79, 79, 79);">封装类和模块</font>
+ <font style="color:rgb(79, 79, 79);">实现函数柯里化</font>

## <font style="color:rgb(79, 79, 79);">闭包一定会造成内存泄漏吗？</font>
<font style="color:rgb(79, 79, 79);">闭包并不一定会造成内存泄漏，如果在使用闭包后变量没有及时销毁，可能会造成内存泄漏的风险。只要合理的使用闭包，就不会造成内存泄漏。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

## <font style="color:#DF2A3F;">Vue生命周期</font>
**创建前后：**

+ `<font style="color:rgb(79, 79, 79);">beforeCreate（创建前）：</font>`<font style="color:rgb(79, 79, 79);"> 数据观测和初始化事件还未开始，不能访问</font>`<font style="color:rgb(79, 79, 79);">data</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">computed</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">watch</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">methods</font>`<font style="color:rgb(79, 79, 79);">上的数据方法。</font>
+ `<font style="color:rgb(79, 79, 79);">created(创建后)：</font>`<font style="color:rgb(79, 79, 79);">实例创建完成，可以访问</font>`<font style="color:rgb(79, 79, 79);">data</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">computed</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">watch</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">methods</font>`<font style="color:rgb(79, 79, 79);">上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。</font>

**挂载前后：**

+ `<font style="color:rgb(79, 79, 79);">beforeMount（挂载前）:</font>`<font style="color:rgb(79, 79, 79);"> Vue实例还未挂在到页面HTML上，此时可以发起服务器请求</font>
+ `<font style="color:rgb(79, 79, 79);">mounted（挂载后）:</font>`<font style="color:rgb(79, 79, 79);">Vue实例已经挂在完毕，可以操作DOM</font>

**更新前后：**

+ `<font style="color:rgb(79, 79, 79);">beforeUpdate（更新前）:</font>`<font style="color:rgb(79, 79, 79);"> 数据更新之前调用，还未渲染页面</font>
+ `<font style="color:rgb(79, 79, 79);">updated（更新后）:</font>`<font style="color:rgb(79, 79, 79);">DOM重新渲染，此时数据和界面都是新的。</font>

**销毁前后：**

+ `<font style="color:rgb(79, 79, 79);">beforeDestorye（销毁前）:</font>`<font style="color:rgb(79, 79, 79);">实例销毁前调用，这时候能够获取到</font>`<font style="color:rgb(79, 79, 79);">this</font>`
+ `<font style="color:rgb(79, 79, 79);">destoryed（销毁后）:</font>`<font style="color:rgb(79, 79, 79);">实例销毁后调用，实例完全被销毁。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

## <font style="color:#DF2A3F;">双向数据绑定的原理</font>
<font style="color:rgb(79, 79, 79);">采用</font>**数据劫持**<font style="color:rgb(79, 79, 79);">结合</font>**发布者-订阅者模式**<font style="color:rgb(79, 79, 79);">的方式，</font>`<font style="color:rgb(79, 79, 79);">data</font>`<font style="color:rgb(79, 79, 79);">数据在初始化的时候，会实例化一个</font>`<font style="color:rgb(79, 79, 79);">Observe</font>`<font style="color:rgb(79, 79, 79);">类，在它会将</font>`<font style="color:rgb(79, 79, 79);">data</font>`<font style="color:rgb(79, 79, 79);">数据进行递归遍历，并通过</font>`<font style="color:rgb(79, 79, 79);">Object.defineProperty</font>`<font style="color:rgb(79, 79, 79);">方法，给每个值添加上一个</font>`<font style="color:rgb(79, 79, 79);">getter</font>`<font style="color:rgb(79, 79, 79);">和一个</font>`<font style="color:rgb(79, 79, 79);">setter</font>`<font style="color:rgb(79, 79, 79);">。在数据读取的时候会触发</font>`<font style="color:rgb(79, 79, 79);">getter</font>`<font style="color:rgb(79, 79, 79);">进行依赖（Watcher）收集，当数据改变时，会触发</font>`<font style="color:rgb(79, 79, 79);">setter</font>`<font style="color:rgb(79, 79, 79);">，对刚刚收集的依赖进行触发，并且更新</font>`<font style="color:rgb(79, 79, 79);">watcher</font>`<font style="color:rgb(79, 79, 79);">通知视图进行渲染。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

# <font style="color:rgb(79, 79, 79);">Vuex</font>
## <font style="color:rgb(79, 79, 79);">Vuex 的原理</font>
`<font style="color:rgb(79, 79, 79);">Vuex</font>`<font style="color:rgb(79, 79, 79);">是专门为</font>`<font style="color:rgb(79, 79, 79);">Vue</font>`<font style="color:rgb(79, 79, 79);">设计的状态管理，当</font>`<font style="color:rgb(79, 79, 79);">Vue</font>`<font style="color:rgb(79, 79, 79);">从</font>`<font style="color:rgb(79, 79, 79);">store</font>`<font style="color:rgb(79, 79, 79);">中读取数据后，数据发生改变，组件中的数据也会发生变化。 </font>![](https://cdn.nlark.com/yuque/0/2024/webp/45412035/1732166793634-5bb7b4dc-ead3-4de2-a741-1e2445027c34.webp)

+ `<font style="color:rgb(79, 79, 79);">Vue Components</font>`<font style="color:rgb(79, 79, 79);"> 负责接收用户操作交互行为，执行dispatch触发对应的action进行回应</font>
+ `<font style="color:rgb(79, 79, 79);">dispatch</font>`<font style="color:rgb(79, 79, 79);">唯一能执行action的方法</font>
+ `<font style="color:rgb(79, 79, 79);">action</font>`<font style="color:rgb(79, 79, 79);">用来接收components的交互行为，包含异步同步操作</font>
+ `<font style="color:rgb(79, 79, 79);">commit</font>`<font style="color:rgb(79, 79, 79);">对mutation进行提交，唯一能执行mutation的方法</font>
+ `<font style="color:rgb(79, 79, 79);">mutation</font>`<font style="color:rgb(79, 79, 79);">唯一可以修改state状态的方法</font>
+ `<font style="color:rgb(79, 79, 79);">state</font>`<font style="color:rgb(79, 79, 79);">页面状态管理容器，用于存储状态</font>
+ `<font style="color:rgb(79, 79, 79);">getters</font>`<font style="color:rgb(79, 79, 79);">读取state方法</font>

<font style="color:rgb(79, 79, 79);">Vue组件接收交互行为，调用</font>`<font style="color:rgb(79, 79, 79);">dispatch</font>`<font style="color:rgb(79, 79, 79);">方法触发</font>`<font style="color:rgb(79, 79, 79);">action</font>`<font style="color:rgb(79, 79, 79);">相关处理，若页面状态需要改变，则调用</font>`<font style="color:rgb(79, 79, 79);">commit</font>`<font style="color:rgb(79, 79, 79);">方法提交</font>`<font style="color:rgb(79, 79, 79);">mutation</font>`<font style="color:rgb(79, 79, 79);">修改</font>`<font style="color:rgb(79, 79, 79);">state</font>`<font style="color:rgb(79, 79, 79);">，通过</font>`<font style="color:rgb(79, 79, 79);">getters</font>`<font style="color:rgb(79, 79, 79);">获取到</font>`<font style="color:rgb(79, 79, 79);">state</font>`<font style="color:rgb(79, 79, 79);">新值，重新渲染</font>`<font style="color:rgb(79, 79, 79);">Vue Components</font>`<font style="color:rgb(79, 79, 79);">，界面随之更新。</font>

### <font style="color:#DF2A3F;">2. 路由的hash和history模式的区别</font>
<font style="color:rgb(79, 79, 79);">Vue-Router有两种模式：</font>**hash模式**<font style="color:rgb(79, 79, 79);">和</font>**history模式**<font style="color:rgb(79, 79, 79);">。默认的路由模式是hash模式。</font>

#### <font style="color:rgb(79, 79, 79);">1. hash模式</font>
**简介：**<font style="color:rgb(79, 79, 79);"> hash模式是开发中默认的模式，它的URL带着一个#，例如：</font>[www.abc.com/#/vue](https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2F%23%2Fvue)<font style="color:rgb(79, 79, 79);">，它的hash值就是</font>`<font style="color:rgb(79, 79, 79);">#/vue</font>`<font style="color:rgb(79, 79, 79);">。</font>

**特点**<font style="color:rgb(79, 79, 79);">：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</font>

**原理：**<font style="color:rgb(79, 79, 79);"> hash模式的主要原理就是</font>**onhashchange()事件**<font style="color:rgb(79, 79, 79);">：</font>

```plain
javascript

 代码解读
复制代码window.onhashchange = function(event){
	console.log(event.oldURL, event.newURL);
	let hash = location.hash.slice(1);
}
```

<font style="color:rgb(79, 79, 79);">使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</font>

#### <font style="color:rgb(79, 79, 79);">2. history模式</font>
**简介：**<font style="color:rgb(79, 79, 79);"> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 </font>**特点：**<font style="color:rgb(79, 79, 79);"> 当使用history模式时，URL就像这样：</font>[abc.com/user/id](https://link.juejin.cn?target=http%3A%2F%2Fabc.com%2Fuser%2Fid)<font style="color:rgb(79, 79, 79);">。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 </font>**API：**<font style="color:rgb(79, 79, 79);"> history api可以分为两大部分，切换历史状态和修改历史状态：</font>

+ **修改历史状态**<font style="color:rgb(79, 79, 79);">：包括了 HTML5 History Interface 中新增的 </font>`<font style="color:rgb(79, 79, 79);">pushState()</font>`<font style="color:rgb(79, 79, 79);"> 和 </font>`<font style="color:rgb(79, 79, 79);">replaceState()</font>`<font style="color:rgb(79, 79, 79);"> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</font>
+ **切换历史状态：**<font style="color:rgb(79, 79, 79);"> 包括</font>`<font style="color:rgb(79, 79, 79);">forward()</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">back()</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">go()</font>`<font style="color:rgb(79, 79, 79);">三个方法，对应浏览器的前进，后退，跳转操作。</font>

<font style="color:rgb(79, 79, 79);">虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</font>

<font style="color:rgb(79, 79, 79);">如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</font>

```plain
javascript

 代码解读
复制代码const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

#### <font style="color:rgb(79, 79, 79);">3. 两种模式对比</font>
<font style="color:rgb(79, 79, 79);">调用 history.pushState() 相比于直接修改 hash，存在以下优势:</font>

+ <font style="color:rgb(79, 79, 79);">pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</font>
+ <font style="color:rgb(79, 79, 79);">pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</font>
+ <font style="color:rgb(79, 79, 79);">pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</font>
+ <font style="color:rgb(79, 79, 79);">pushState() 可额外设置 title 属性供后续使用。</font>
+ <font style="color:rgb(79, 79, 79);">hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</font>

<font style="color:rgb(79, 79, 79);">hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</font>

<font style="color:rgb(79, 79, 79);"></font>

## <font style="color:#DF2A3F;">七、虚拟DOM</font>
### <font style="color:#DF2A3F;">1. 对虚拟DOM的理解？</font>
<font style="color:rgb(79, 79, 79);">从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</font>

<font style="color:rgb(79, 79, 79);">虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</font>

<font style="color:rgb(79, 79, 79);">另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</font>

### <font style="color:rgb(79, 79, 79);">2. 虚拟DOM的解析过程</font>
<font style="color:rgb(79, 79, 79);">虚拟DOM的解析过程：</font>

+ <font style="color:rgb(79, 79, 79);">首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</font>
+ <font style="color:rgb(79, 79, 79);">当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</font>
+ <font style="color:rgb(79, 79, 79);">最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</font>

### <font style="color:rgb(79, 79, 79);">3. 为什么要用虚拟DOM</font>
**（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能**<font style="color:rgb(79, 79, 79);"> 看一下页面渲染的流程：</font>**解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler**<font style="color:rgb(79, 79, 79);"> 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</font>

+ <font style="color:rgb(79, 79, 79);">真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</font>
+ <font style="color:rgb(79, 79, 79);">虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</font>

<font style="color:rgb(79, 79, 79);">Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 </font>**（2）跨平台**<font style="color:rgb(79, 79, 79);"> Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</font>

### <font style="color:rgb(79, 79, 79);">4. 虚拟DOM真的比真实DOM性能好吗</font>
+ <font style="color:rgb(79, 79, 79);">首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</font>
+ <font style="color:rgb(79, 79, 79);">正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</font>

### <font style="color:#DF2A3F;">01｜为什么要用 Webpack</font>
没用 webpack 之前有什么问题：

1. **全局变量污染：** 传统的 JavaScript 开发中，所有变量和函数默认都是全局的；
2. **手动管理依赖顺序麻烦：** 在`<script />`里引入外部 JS 难度随着项目体量越来越难；
3. **手动进行性能优化繁琐：** 如文件合并、压缩、减少 HTTP 请求，繁琐且易出错；
4. **要确保代码在不同浏览器中的兼容性：** 需要手动编写或引入 polyfills、babel 等第三方工具；

对于小型项目来说，这些问题不太明显。但随之项目规模逐渐增大，再去解决这些问题就很吃力，这个时候我们就**需要一种工具来帮我们把这些机械性问题，自动化的解决掉，让开发者更加专注在业务层面**。

### 02｜webpack 有哪些常见配置
有两种方式可以来控制 webpack 的行为。

+ **配置文件（默认）** ： webpack 会读取 `webpack.config.js`；
+ **命令行**：或者通过 cli 参数 `--config` 来指定其他配置文件；

配置文件通过 CommonJS 导出一个对象`module.exports = {}`，对象中的各种属性对应不同的 webpack 配置。当命令行参数与配置文件出现冲突时，以命令行参数为准。常见配置见下文代码：

1. **入口(entry)：** 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。
2. **输出(output)：** 告诉 webpack 在哪输出它所创建的 bundles，以及如何命名这些文件。
3. **转换器(module)：** 声明 loader 用法。将某个源码字符串转换成另一个源码字符串返 
    - test：正则表达式，用于标识 Loader 转换哪类文件。
    - use：字符串，标识使用哪些 Loader。调用规则从后向前，如下文处理 css 的 loader 会先使用 `css-loader` 处理，得到的结果再传给 `style-loader`。
4. **插件(plugins)：** 扩展了 webpack 的功能，并提供其编译过程中的一些事件钩子，plugin 去监听这些内容然后进行操作。



### <font style="color:#DF2A3F;">11. 实现数组的扁平化</font>
<font style="color:rgb(79, 79, 79);">在JavaScript中，数组扁平化就是将一个嵌套数组转换为一个一维数组。这可以通过多种方法来实现，下面我将提供几种常见的方法：</font>

**方法一：使用递归**

```plain
ini

 代码解读
复制代码function flattenArray(arr) {  
    let result = [];  
    for (let i = 0; i < arr.length; i++) {  
        if (Array.isArray(arr[i])) {  
            result = result.concat(flattenArray(arr[i]));  
        } else {  
            result.push(arr[i]);  
        }  
    }  
    return result;  
}  
  
let nestedArray = [1, [2, [3, [4]], 5]];  
console.log(flattenArray(nestedArray)); // 输出 [1, 2, 3, 4, 5]
```

**方法二：使用**`**reduce**`**方法**

```plain
javascript

 代码解读
复制代码function flattenArray(arr) {  
    return arr.reduce((acc, val) => Array.isArray(val) ? [...acc, ...flattenArray(val)] : [...acc, val], []);  
}  
  
let nestedArray = [1, [2, [3, [4]], 5]];  
console.log(flattenArray(nestedArray)); // 输出 [1, 2, 3, 4, 5]
```

**方法三：使用扩展运算符（ES6）**

```plain
ini

 代码解读
复制代码function flattenArray(arr) {  
    while (arr.some(item => Array.isArray(item))) {  
        arr = [].concat(...arr);  
    }  
    return arr;  
}  
  
let nestedArray = [1, [2, [3, [4]], 5]];  
console.log(flattenArray(nestedArray)); // 输出 [1, 2, 3, 4, 5]
```

**方法四：使用**`**flat**`**方法（ES10）**

<font style="color:rgb(79, 79, 79);">从ES10开始，JavaScript引入了</font>`<font style="color:rgb(79, 79, 79);">flat</font>`<font style="color:rgb(79, 79, 79);">方法，它可以直接用来扁平化数组。</font>`<font style="color:rgb(79, 79, 79);">flat</font>`<font style="color:rgb(79, 79, 79);">方法还可以接受一个可选的参数，表示要展开的嵌套层数。</font>

```plain
ini

 代码解读
复制代码let nestedArray = [1, [2, [3, [4]], 5]];  
console.log(nestedArray.flat(Infinity)); // 输出 [1, 2, 3, 4, 5]
```

<font style="color:rgb(79, 79, 79);">在上面的代码中，</font>`<font style="color:rgb(79, 79, 79);">Infinity</font>`<font style="color:rgb(79, 79, 79);">用作</font>`<font style="color:rgb(79, 79, 79);">flat</font>`<font style="color:rgb(79, 79, 79);">方法的参数，意味着无论嵌套多少层，都会展开到一维数组。</font>

<font style="color:rgb(79, 79, 79);">在这些方法中，</font>`<font style="color:rgb(79, 79, 79);">flat</font>`<font style="color:rgb(79, 79, 79);">方法是最简洁和最容易理解的，但是需要注意的是，它可能在一些较旧的浏览器中不被支持。如果需要考虑兼容性，你可能需要使用其他方法，或者结合polyfill来提供对</font>`<font style="color:rgb(79, 79, 79);">flat</font>`<font style="color:rgb(79, 79, 79);">方法的支持。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

### <font style="color:#DF2A3F;">06｜Loader 和 Plugin有什么区别（高频）</font>
`<font style="color:rgb(79, 79, 79);">Loader</font>`<font style="color:rgb(79, 79, 79);"> 转换器，用于转换模块的源代码。可以将不同类型的文件（如 CSS、图像、TypeScript 等）转换为 JavaScript 模块，从而使它们能够被 Webpack 处理。以下是 CSS 转换的例子：</font>

```plain
JS

 代码解读
复制代码// css-loader 转换后的 JavaScript 模块
module.exports = {
  // CSS 内容被转换为字符串
  css: "body { background-color: lightblue; } h1 { color: navy; }"
};

// style-loader 会将这些样式注入到 DOM 中
const style = document.createElement('style');
style.textContent = module.exports.css;
document.head.appendChild(style);
```

`<font style="color:rgb(79, 79, 79);">Plugin</font>`<font style="color:rgb(79, 79, 79);"> 插件是 Webpack 的扩展，执行范围更广，可以在构建过程的各个阶段进行操作和自定义功能。Webpack 会提供一些 API 和 生命周期钩子方便开发者触达到除了编译之外的一些环节来执行操作。</font>

**使用场景**

+ <font style="color:rgb(79, 79, 79);">压缩输出的 JavaScript 文件（如使用 TerserPlugin）。</font>
+ <font style="color:rgb(79, 79, 79);">提取 CSS 到单独的文件（如使用 MiniCssExtractPlugin）。</font>
+ <font style="color:rgb(79, 79, 79);">生成 HTML 文件并自动注入打包后的资源（如使用 HtmlWebpackPlugin）。</font>
+ <font style="color:rgb(79, 79, 79);">清理输出目录（如使用 CleanWebpackPlugin）。</font>

### <font style="color:rgb(79, 79, 79);">07｜写 Loader 的步骤和思路</font>
<font style="color:rgb(79, 79, 79);">  
</font>

<font style="color:rgb(79, 79, 79);"></font>

### <font style="color:#DF2A3F;">4.手写promise</font>
<font style="color:rgb(79, 79, 79);">在JavaScript中，</font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 是一个用于处理异步操作的对象。它代表了一个可能现在、将来或永远不会完成的异步操作及其结果值。下面是一个简化的 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 实现示例，只包括最基本的功能：</font>

```plain
ini

 代码解读
复制代码function MyPromise(executor) {  
  this.status = 'pending'; // 初始状态为pending  
  this.value = undefined; // 用于保存异步操作的结果  
  this.reason = undefined; // 用于保存异步操作失败的原因  
  this.onFulfilledCallbacks = []; // 成功回调函数队列  
  this.onRejectedCallbacks = []; // 失败回调函数队列  
  
  // 立即执行executor函数，传入resolve和reject函数  
  const resolve = (value) => {  
    if (this.status !== 'pending') return;  
    this.status = 'fulfilled';  
    this.value = value;  
    this.onFulfilledCallbacks.forEach(callback => callback());  
  };  
  
  const reject = (reason) => {  
    if (this.status !== 'pending') return;  
    this.status = 'rejected';  
    this.reason = reason;  
    this.onRejectedCallbacks.forEach(callback => callback());  
  };  
  
  // 捕获executor函数中抛出的异常  
  try {  
    executor(resolve, reject);  
  } catch (error) {  
    reject(error);  
  }  
}  
  
// then方法，用于指定Promise成功或失败时要执行的回调函数  
MyPromise.prototype.then = function(onFulfilled, onRejected) {  
  const promise2 = new MyPromise((resolve, reject) => {  
    // 处理Promise状态为fulfilled的情况  
    if (this.status === 'fulfilled') {  
      setTimeout(() => {  
        try {  
          const result = onFulfilled(this.value);  
          resolve(result);  
        } catch (error) {  
          reject(error);  
        }  
      }, 0);  
    }  
    // 处理Promise状态为rejected的情况  
    else if (this.status === 'rejected') {  
      setTimeout(() => {  
        try {  
          const result = onRejected(this.reason);  
          resolve(result);  
        } catch (error) {  
          reject(error);  
        }  
      }, 0);  
    }  
    // 如果Promise状态还为pending，则将其回调函数加入队列中  
    else {  
      this.onFulfilledCallbacks.push(() => {  
        setTimeout(() => {  
          try {  
            const result = onFulfilled(this.value);  
            resolve(result);  
          } catch (error) {  
            reject(error);  
          }  
        }, 0);  
      });  
      this.onRejectedCallbacks.push(() => {  
        setTimeout(() => {  
          try {  
            const result = onRejected(this.reason);  
            resolve(result);  
          } catch (error) {  
            reject(error);  
          }  
        }, 0);  
      });  
    }  
  });  
  return promise2;  
};  
  
// 静态方法resolve，用于将现有值转换为Promise对象  
MyPromise.resolve = function(value) {  
  return new MyPromise(resolve => {  
    resolve(value);  
  });  
};  
  
// 静态方法reject，用于返回一个带有拒绝理由的Promise对象  
MyPromise.reject = function(reason) {  
  return new MyPromise((_, reject) => {  
    reject(reason);  
  });  
};  
  
// 使用示例  
const promise = new MyPromise((resolve, reject) => {  
  setTimeout(() => {  
    resolve('成功!');  
  }, 1000);  
});  
  
promise.then(  
  value => console.log(value), // 输出 '成功!'  
  reason => console.log(reason) // 不会执行  
);
```

<font style="color:rgb(79, 79, 79);">这个简化的 </font>`<font style="color:rgb(79, 79, 79);">MyPromise</font>`<font style="color:rgb(79, 79, 79);"> 实现包括了以下基本功能：</font>

+ `<font style="color:rgb(79, 79, 79);">executor</font>`<font style="color:rgb(79, 79, 79);"> 函数接受 </font>`<font style="color:rgb(79, 79, 79);">resolve</font>`<font style="color:rgb(79, 79, 79);"> 和 </font>`<font style="color:rgb(79, 79, 79);">reject</font>`<font style="color:rgb(79, 79, 79);"> 两个参数，并立即执行。</font>
+ `<font style="color:rgb(79, 79, 79);">resolve</font>`<font style="color:rgb(79, 79, 79);"> 和 </font>`<font style="color:rgb(79, 79, 79);">reject</font>`<font style="color:rgb(79, 79, 79);"> 函数用于改变 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 的状态，并触发相应的回调函数。</font>
+ `<font style="color:rgb(79, 79, 79);">then</font>`<font style="color:rgb(79, 79, 79);"> 方法用于指定 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 成功或失败时要执行的回调函数，并返回一个新的 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 对象。</font>
+ `<font style="color:rgb(79, 79, 79);">MyPromise.resolve</font>`<font style="color:rgb(79, 79, 79);"> 和 </font>`<font style="color:rgb(79, 79, 79);">MyPromise.reject</font>`<font style="color:rgb(79, 79, 79);"> 是两个静态方法，用于创建已经解决或拒绝的 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 对象。</font>

<font style="color:rgb(79, 79, 79);">请注意，这个实现省略了很多特性，比如链式调用、错误冒泡、</font>`<font style="color:rgb(79, 79, 79);">catch</font>`<font style="color:rgb(79, 79, 79);"> 方法、</font>`<font style="color:rgb(79, 79, 79);">finally</font>`<font style="color:rgb(79, 79, 79);"> 方法、以及微任务队列的处理等。在真实的项目中，通常会使用原生的 </font>`<font style="color:rgb(79, 79, 79);">Promise</font>`<font style="color:rgb(79, 79, 79);"> 对象，因为它已经由JavaScript引擎进行了优化，并且提供了完整的API支持。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

### <font style="color:#DF2A3F;">17. 实现发布-订阅模式</font>
<font style="color:rgb(79, 79, 79);">发布-订阅模式是一种消息传递模式，允许发送者（发布者）发送消息，而不直接将其发送给特定的接收者（订阅者）。同样，接收者可以订阅一个或多个消息，而无需知道发送者的身份。这种模式在事件驱动编程中非常常见，比如浏览器的DOM事件、Node.js的事件等。</font>

<font style="color:rgb(79, 79, 79);">下面是一个简单的JavaScript实现发布-订阅模式的例子：</font>

```plain
kotlin

 代码解读
复制代码class PubSub {  
    constructor() {  
        this.subscribers = {};  
    }  
  
    // 订阅事件  
    subscribe(event, callback) {  
        if (!this.subscribers[event]) {  
            this.subscribers[event] = [];  
        }  
        this.subscribers[event].push(callback);  
    }  
  
    // 取消订阅事件  
    unsubscribe(event, callback) {  
        if (this.subscribers[event]) {  
            this.subscribers[event] = this.subscribers[event].filter(subCallback => subCallback !== callback);  
        }  
    }  
  
    // 发布事件  
    publish(event, data) {  
        if (this.subscribers[event]) {  
            this.subscribers[event].forEach(callback => callback(data));  
        }  
    }  
}  
  
// 使用示例  
const pubsub = new PubSub();  
  
// 订阅事件  
pubsub.subscribe('myEvent', data => console.log('Received data:', data));  
  
// 发布事件  
pubsub.publish('myEvent', 'Hello, world!'); // 输出: Received data: Hello, world!  
  
// 取消订阅事件  
pubsub.unsubscribe('myEvent', (data) => console.log('Received data:', data));  
  
// 再次发布事件，此时不会有输出，因为已经取消了订阅  
pubsub.publish('myEvent', 'Hello again!');
```

<font style="color:rgb(79, 79, 79);">在这个例子中，我们创建了一个</font>`<font style="color:rgb(79, 79, 79);">PubSub</font>`<font style="color:rgb(79, 79, 79);">类，它有三个方法：</font>`<font style="color:rgb(79, 79, 79);">subscribe</font>`<font style="color:rgb(79, 79, 79);">、</font>`<font style="color:rgb(79, 79, 79);">unsubscribe</font>`<font style="color:rgb(79, 79, 79);">和</font>`<font style="color:rgb(79, 79, 79);">publish</font>`<font style="color:rgb(79, 79, 79);">。</font>`<font style="color:rgb(79, 79, 79);">subscribe</font>`<font style="color:rgb(79, 79, 79);">方法用于订阅事件，它将回调函数存储在一个以事件名为键的对象中。</font>`<font style="color:rgb(79, 79, 79);">unsubscribe</font>`<font style="color:rgb(79, 79, 79);">方法用于取消订阅事件，它从存储的回调函数中移除指定的回调函数。</font>`<font style="color:rgb(79, 79, 79);">publish</font>`<font style="color:rgb(79, 79, 79);">方法用于发布事件，它遍历所有订阅了该事件的回调函数，并调用它们。</font>

<font style="color:rgb(79, 79, 79);">  
</font>

### 


